
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <opencv2/opencv.hpp>
using namespace cv;
using namespace std;

int keycnt = 0;
///// M E M O ////////// ///////////////////////////////////////////
//
//#1. INPUT
//#   움직임이 존재하는 2장의 연속 프레임영상을 입력으로 사용
//
//#2. CORNER DETECTION
//#   CORNER DETECTION을 이용해 2장의 영상 중 앞쪽 영상의 Key Point를 도출
//#   SIFT
//
//#3. MOTION VECTOR
//#   OPTICAL FLOW를 이용하여 앞쪽 영상의 KEYPOINT픽셀의 MOTION VECTOR(x, y)를 도출.
//
////////////////////////////////////////////////////////////////////
Mat grayscale(Mat frame, int w, int h); //basic
float Gaussian(int u, int v, float sigma);//basic
Mat GaussianFilter(Mat frame, int w, int h, float sigma);//basic
Mat Resize(Mat frame, float ratio, int w, int h);//basic
// grayscale, Guassian, Gaussian filter : 상용함수 사용예정 cv2.gaussian() cv2.resize()

/////////////////////////////////////////////////////////////////////////////////////////////////

//(module - 1)
void MakeGaussians(Mat** Octaves, Mat frame, int level, int size, int w, int h);

int main()
{
	//1.input
	// frame size
	int w = 640;
	int h = 360;
	//gaussian filter를 위한 파라미터의 초기값
	float sigma = 1;
	//img load
	Mat frame1 = imread("C:\img\cat_0.jpg", IMREAD_COLOR);
	Mat frame2 = imread("C:\img\cat_1.jpg", IMREAD_COLOR);
	Mat frame3 = imread("C:\img\cat_2.jpg", IMREAD_COLOR);
	Mat frame4 = imread("C:\img\cat_3.jpg", IMREAD_COLOR);
	Mat frame5 = imread("C:\img\cat_4.jpg", IMREAD_COLOR);

	waitKey(0);
	if (frame1.empty() || frame2.empty())
	{
		cout << "NOT FIND" << endl;
		return -1;
	}

	//2.Multi-Scale-Extrema - Detection

	//grayscale
	Mat frame_g;
	Mat frame_g2;
	Mat frame_g3;
	Mat frame_g4;
	Mat frame_g5;
	cv::cvtColor(frame1, frame_g, COLOR_RGB2GRAY);
	cv::cvtColor(frame2, frame_g2, COLOR_RGB2GRAY);



	//octave /DoG : 영상처리를 위해 필요한 이미지(processed) 저장 배열 
	Mat** octaves = new Mat * [4];
	for (int i = 0; i < 4; i++)
	{
		octaves[i] = new Mat[5];
	}
	Mat** DoG = new Mat * [4];
	for (int i = 0; i < 4; i++)
	{
		DoG[i] = new Mat[4];
	}

	MakeGaussians(octaves, frame_g, 4, 5, w, h);//level:4 size:5
	for (int i = 0; i < 4; i++)
	{
		for (int j = 1; j < 5; j++)
		{
			imshow("frame", octaves[i][j]);
		}
	}
	waitKey(0);

	return 0;
}






Mat grayscale(Mat frame, int w, int h)
{
	//float coef_r = 0.299;
	//float coef_g = 0.587;
	//float coef_b = 0.114;
	Mat result(h, w, CV_8UC1);
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{

			int r = frame.at<Vec3b>(i, j)[0];
			int g = frame.at<Vec3b>(i, j)[1];
			int b = frame.at<Vec3b>(i, j)[2];
			result.at<uchar>(i, j) = int((r * 0.299 + g * 0.587 + b * 0.114));
			//result.at<uchar>(i, j) = int((r + g + b) / 3);
		}
	}

	return result;
}
float Gaussian(int u, int v, float sigma)
{
	float pi = 3.14;
	float result = (
		(1 / (2 * pi * pow(sigma, 2))) *
		exp(
			(-1 * (pow(u, 2) + pow(v, 2))
				) / (2 * pow(sigma, 2))
		)
		);

	return result;
}
Mat GaussianFilter(Mat frame, int w, int h, float sigma)
{
	Mat result = frame.clone();
	if (sigma == 0)
		return result;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			uchar tmp = { 0 };
			float sumone = 0;
			for (int k = -int(round(sigma * 2)); k <= int(round(sigma * 2)); k++)
			{
				for (int l = -int(round(sigma * 2)); l <= int(round(sigma * 2)); l++)
				{
					if (i + k >= h || j + l >= w || i + k < 0 || j + l < 0) {
						continue;
					}
					tmp = tmp + Gaussian(k, l, sigma) * frame.at<uchar>(min(max(0, i + k), h - 1), min(max(j + l, 0), w - 1));
					sumone = sumone + Gaussian(k, l, sigma);
				}
			}
			result.at<uchar>(i, j) = uchar(round(tmp / sumone));
		}
	}
	return result;
}


Mat Resize(Mat frame, float ratio, int w, int h)
{
	int row = int(h * ratio);
	int col = int(w * ratio);
	Mat downsampled(row, col, CV_8UC1);
	for (int i = 0; i < row - 1; i++)
	{
		for (int j = 0; j < col - 1; j++)
		{
			downsampled.at<uchar>(i, j) = frame.at<uchar>(int((1 / ratio) * i), int((1 / ratio) * j));
		}
	}
	return downsampled;
}

void MakeGaussians(Mat** Octaves, Mat frame, int level, int size, int w, int h)
{
	int w_d = w;
	int h_d = h;
	Mat downsampled = frame.clone();
	float sigma = 0;
	for (int i = 0; i < level; i++) //다른 octave : size down
	{
		sigma = 0.5;
		float sigma_ratio = 0.5;//파라미터
		float ratio = 0.5;
		if (i == 0)
			ratio = 1;
		downsampled = Resize(downsampled, ratio, w_d, h_d);
		Octaves[i][0] = Mat(downsampled.clone());
		w_d = int(w_d * ratio);
		h_d = int(h_d * ratio);
		for (int j = 1; j < size; j++) //같은octave: sigma값 변경
		{
			Octaves[i][j] = GaussianFilter(downsampled, w_d, h_d, sigma);
			sigma = sigma + sigma_ratio;//* sigma_ratio;

		}
	}

}
